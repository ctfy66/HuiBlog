---
title: 'Gemini CLI研究'
date: '2025-12-13'
---
# Gemini CLI研究


通过学习gemini CLI的开源代码库. 学习如何构建一个能够处理复杂任务的agent.

同时会用claude code 来辅助阅读代码.

# 架构

由两个包组成cli, core.

cli负责用户交互以及终端显示. core负责整个ReAct循环

这样分离的结构将agent的流程和应用层(CLI)分离出来. 便于核心agent能力的复用.

核心架构图

![Untitled diagram-2025-12-07-090327.svg](/posts/Untitled_diagram-2025-12-07-090327.svg)

# 工具调用

![v2-250b4b19af53f220c4f3d421bd8126ff_r.png](/posts/v2-250b4b19af53f220c4f3d421bd8126ff_r.png)

## tool的设计

```tsx
'Edit',
      `Replaces text within a file. By default, replaces a single occurrence, but can replace multiple occurrences when \`expected_replacements\` is specified. This tool requires providing significant context around the change to ensure precise targeting. Always use the ${READ_FILE_TOOL_NAME} tool to examine the file's current content before attempting a text replacement.

      The user has the ability to modify the \`new_string\` content. If modified, this will be stated in the response.

Expectation for required parameters:
1. \`file_path\` is the path to the file to modify.
2. \`old_string\` MUST be the exact literal text to replace (including all whitespace, indentation, newlines, and surrounding code etc.).
3. \`new_string\` MUST be the exact literal text to replace \`old_string\` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.
4. NEVER escape \`old_string\` or \`new_string\`, that would break the exact literal text requirement.
**Important:** If ANY of the above are not satisfied, the tool will fail. CRITICAL for \`old_string\`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail.
**Multiple replacements:** Set \`expected_replacements\` to the number of occurrences you want to replace. The tool will replace ALL occurrences that match \`old_string\` exactly. Ensure the number of replacements matches your expectation.`,
      Kind.Edit,
      {
        properties: {
          file_path: {
            description: 'The path to the file to modify.',
            type: 'string',
          },
          old_string: {
            description:
              'The exact literal text to replace, preferably unescaped. For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. For multiple replacements, specify expected_replacements parameter. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail.',
            type: 'string',
          },
          new_string: {
            description:
              'The exact literal text to replace `old_string` with, preferably unescaped. Provide the EXACT text. Ensure the resulting code is correct and idiomatic.',
            type: 'string',
          },
          expected_replacements: {
            type: 'number',
            description:
              'Number of replacements expected. Defaults to 1 if not specified. Use when you want to replace multiple occurrences.',
            minimum: 1,
          },
        },
        required: ['file_path', 'old_string', 'new_string'],
        type: 'object',
      },
      true, // isOutputMarkdown
      false, // canUpdateOutput
      messageBus,
    );
  }
```

可以看到包含了tool 的description, 参数的schema 

以下内容来自知乎专栏[https://zhuanlan.zhihu.com/p/1976305837011116648](https://zhuanlan.zhihu.com/p/1976305837011116648)

### **工具的声明与实现**

以 read_file 工具为例（位于packages/core/src/tools/read-file.ts）。

**声明** : 工具首先需要向大模型进行自我介绍。这是通过一个符合 JSON Schema 规范的配置对象完成的。它详细定义了工具的名称（如read_file）、功能描述（用于读取文件内容），以及最重要的——参数（如 absolute_path、offset等）。这份介绍是模型理解并决定如何使用该工具的依据。

**实现** : 当模型决定调用该工具后，其实际的执行逻辑则被封装在一个 Invocation 类中。该类的 execute()方法包含了真正的功能代码，例如调用文件系统 API 来读取文件。

### **统一的“工具注册表”**

所有内置或外部的工具，会被工具注册表ToolRegistry（位于 packages/core/src/tools/tool-registry.ts）来管理。

在应用启动时，Config模块会负责创建所有内置工具的实例，并逐一注册到表中。当需要与大模型交互时，系统会从注册表中提取所有工具的“声明”信息，统一提交给模型，让模型知道它当前拥有哪些可用的能力。同样，当模型请求执行某个工具时，调度器也会通过注册表来查找并执行它。

### **安全执行的确认机制**

对于 run_shell_command （实现位于packages/core/src/tools/shell.ts）这类可能造成风险的执行工具，gemini-cli 建立了一套安全确认机制，其决策逻辑位于 core 包，而 UI 交互则由 cli 包呈现。

**1.决策点**： 当一个高危工具被请求执行时，CoreToolScheduler 会首先调用该工具的 shouldConfirmExecute() 方法，以确定工具能否被执行。

**2.检查**: 以shell工具为例，shouldConfirmExecute() 会进行检查：该命令是否在用户本次会话中已经授权过？

**3.请求确认:** 如果授权检查未通过， CoreToolScheduler 会暂停执行，并发送信号至cli层。cli包接收到这个信号后，会渲染一个对话框，展示待执行的命令，并让用户做出是否确认执行的决定。

这套机制确保敏感操作都在用户的明确授权下进行，同时通过会话内白名单等方式避免了不必要的重复确认。

### **MCP拓展：连接外部工具**

gemini-cli通过支持“模型上下文协议”（MCP），可以与任何外部工具服务器进行交互，从而获得扩展能力。

gemini-cli启动时，gemini-cli 会连接在配置中指定的 MCP服务器，并请求对方提供其支持的工具列表。MCP服务器返回工具的声明信息后，gemini-cli 会将它们作为MCP工具注册到自己的ToolRegistry 中。（代码位于packages/core/src/tools/ 目录下的 mcp-client-manager.ts）

当模型决定调用一个MCP外部工具时，其执行流程与内置工具不同是 execute()方法，它通过初始化阶段建立的连接，将参数转发给MCP服务器。它会等待服务器返回执行结果，再将其递交给模型。（代码位于packages/core/src/tools/ 目录下的 mcp-client.ts 、 mcp-tool.ts ）

通过这种方式，gemini-cli 将MCP工具整合进了自身的 ReAct循环中

# 上下文管理

![v2-a2932320e7b54058cc87dd7fe6db7785_r.png](/posts/v2-a2932320e7b54058cc87dd7fe6db7785_r.png)

1.工具输出摘要（Tool Output Summarization）

- 目的：防止单个工具输出过长导致上下文溢出
- 实现位置：packages/core/src/utils/summarizer.ts
- 摘要策略：
    - 结构化输出（如ls结果）：根据上下文提取关键信息
    - 文本内容：直接摘要
    - Shell命令：保留完整错误栈和警告
- Token控制：摘要长度限制为2000 tokens

2.会话摘要（Session Summary）

- 目的：为用户生成对话的一句话摘要（80字符以内）
- 实现位置：packages/core/src/services/sessionSummaryService.ts
- 生成策略：
    - 使用滑动窗口选择最近20条消息
    - 前10条+后10条的组合
    - 超时时间：5秒
- 应用场景：会话历史列表、快速回顾

3.历史压缩

- 实现位置：packages/core/src/services/chatCompressionService.ts
- 触发条件：上下文接近Token限制时
- 压缩方法：
    - 保留系统提示词和最近N轮对话
    - 将旧的对话用LLM生成摘要替代
    - 保持function call/response配对完整性

## 历史压缩机制

当前上下文token达到阈值的50%,触发压缩.

保留当前对话记录的最近30%, 压缩较远的70%. 并且压缩的分割点是user message. 保证完整的工具调用以及模型输出不会被分割.

LLM压缩: 

附上压缩的系统提示词

```tsx
You are the component that summarizes internal chat history into a given structure.

When the conversation history grows too large, you will be invoked to distill the entire history into a concise, structured XML snapshot. This snapshot is CRITICAL, as it will become the agent's *only* memory of the past. The agent will resume its work based solely on this snapshot. All crucial details, plans, errors, and user directives MUST be preserved.

First, you will think through the entire history in a private <scratchpad>. Review the user's overall goal, the agent's actions, tool outputs, file modifications, and any unresolved questions. Identify every piece of information that is essential for future actions.

After your reasoning is complete, generate the final <state_snapshot> XML object. Be incredibly dense with information. Omit any irrelevant conversational filler.

The structure MUST be as follows:

<state_snapshot>
    <overall_goal>
        <!-- A single, concise sentence describing the user's high-level objective. -->
        <!-- Example: "Refactor the authentication service to use a new JWT library." -->
    </overall_goal>

    <key_knowledge>
        <!-- Crucial facts, conventions, and constraints the agent must remember based on the conversation history and interaction with the user. Use bullet points. -->
        <!-- Example:
         - Build Command: \`npm run build\`
         - Testing: Tests are run with \`npm test\`. Test files must end in \`.test.ts\`.
         - API Endpoint: The primary API endpoint is \`https://api.example.com/v2\`.
         
        -->
    </key_knowledge>

    <file_system_state>
        <!-- List files that have been created, read, modified, or deleted. Note their status and critical learnings. -->
        <!-- Example:
         - CWD: \`/home/user/project/src\`
         - READ: \`package.json\` - Confirmed 'axios' is a dependency.
         - MODIFIED: \`services/auth.ts\` - Replaced 'jsonwebtoken' with 'jose'.
         - CREATED: \`tests/new-feature.test.ts\` - Initial test structure for the new feature.
        -->
    </file_system_state>

    <recent_actions>
        <!-- A summary of the last few significant agent actions and their outcomes. Focus on facts. -->
        <!-- Example:
         - Ran \`grep 'old_function'\` which returned 3 results in 2 files.
         - Ran \`npm run test\`, which failed due to a snapshot mismatch in \`UserProfile.test.ts\`.
         - Ran \`ls -F static/\` and discovered image assets are stored as \`.webp\`.
        -->
    </recent_actions>

    <current_plan>
        <!-- The agent's step-by-step plan. Mark completed steps. -->
        <!-- Example:
         1. [DONE] Identify all files using the deprecated 'UserAPI'.
         2. [IN PROGRESS] Refactor \`src/components/UserProfile.tsx\` to use the new 'ProfileAPI'.
         3. [TODO] Refactor the remaining files.
         4. [TODO] Update tests to reflect the API change.
        -->
    </current_plan>
</state_snapshot>
```

# 循环检测

系统实际上有**三种不同层面的循环检测机制**：

工具调用循环, 内容循环, LLM检测循环.

## 一、工具调用循环（跨轮检测）

### 检测对象

**连续相同的工具调用**（工具名 + 参数都相同）

### 触发条件

```
const TOOL_CALL_LOOP_THRESHOLD = 5;

```

**连续 5 次**调用相同工具且参数完全相同

## 二、内容循环（单轮流式输出中检测）

### 检测对象

**LLM 流式输出的文本内容重复**

### 触发条件

```
const CONTENT_LOOP_THRESHOLD = 10;
const CONTENT_CHUNK_SIZE = 50;

```

在单轮流式输出中，相同的 50 字符文本块**重复出现 10 次**且距离很近

**关键点**：

- 使用滑动窗口分析 50 字符的块
- **在单轮 LLM 响应内检测**（流式输出时）
- 检测"吟唱"现象（重复输出相同句子）
- 代码块内不检测（避免误报）

## 三、LLM 智能循环检测（跨多轮检测）

### 检测对象

**复杂的循环模式和认知困境**

### 触发条件

```
const LLM_CHECK_AFTER_TURNS = 30;

```

- 第 30 轮后开始
- 每隔 3-15 轮检查一次（动态调整）
- 分析最近 20 轮对话历史

### 检测的循环类型

```
const LOOP_DETECTION_SYSTEM_PROMPT = `You are a sophisticated AI diagnostic agent specializing in identifying when a conversational AI is stuck in an unproductive state. Your task is to analyze the provided conversation history and determine if the assistant has ceased to make meaningful progress.

An unproductive state is characterized by one or more of the following patterns over the last 5 or more assistant turns:

Repetitive Actions: The assistant repeats the same tool calls or conversational responses a decent number of times. This includes simple loops (e.g., tool_A, tool_A, tool_A) and alternating patterns (e.g., tool_A, tool_B, tool_A, tool_B, ...).

Cognitive Loop: The assistant seems unable to determine the next logical step. It might express confusion, repeatedly ask the same questions, or generate responses that don't logically follow from the previous turns, indicating it's stuck and not advancing the task.

Crucially, differentiate between a true unproductive state and legitimate, incremental progress.
For example, a series of 'tool_A' or 'tool_B' tool calls that make small, distinct changes to the same file (like adding docstrings to functions one by one) is considered forward progress and is NOT a loop. A loop would be repeatedly replacing the same text with the same content, or cycling between a small set of files with no net change.`;

```

### 1. **重复动作模式**

- 简单循环：`tool_A → tool_A → tool_A`
- **交替模式**：`tool_A → tool_B → tool_A → tool_B` ✓
- 无进展的重复修改

### 2. **认知循环**

- LLM 表现困惑
- 重复询问相同问题
- 逻辑不连贯、无法前进

### 3. **能区分正常进展**

- 增量进展（逐个函数添加文档）✓ 不是循环
- 实际循环（反复修改同一处）❌ 是循环

# 总结

gemini CLI的技术亮点:

1. CLI和Core架构分离. 将模型能力从CLI对话独立出来, 便于复用.
2. 生态扩展: 可以自定义hook,tool, mcp. 易于开发者扩展新的能力. 
3. 将控制逻辑交给LLM, 比传统的if_else更智能.